[{"title":"Hexo个人博客进阶-相册","date":"2018-01-28T04:20:25.000Z","path":"2018/01/28/blog2/","text":"之前写过一篇使用github+hexo搭建个人博客的教程，帮助了很多人实现了自己的博客网站，传送门。如果你还没有实现自己的博客网站，可以去看看。但是由于主题作者没有提供相册功能的具体实现，也是有很多人很疑惑，不断的向我提问，说怎么实现相册功能，今天我就详细的介绍一下怎么去实现这个功能。首先，看看我们最终版的实现效果，点击查看，有了目标，才有一步一步的朝向目标前进的动力和方向。 重要前提由于使用了ins获取图片，ins在国内又被墙了，所以，接下来的一些操作需要自备梯子，没有梯子的同学也没关系，使用mac的同学，可以在app store搜索vpn plus(不是广告…)这个软件，可以免费使用vpn翻墙，就是速度跟蜗牛一样慢，其他系统的同学，自行查找可用的梯子吧。如果没有找到，那我也没办法了-_- 分析为了实现相册模块，需要准备的材料： 获取ins提供的接口数据 保存json数据和图片 静态页面（使用ejs魔板） 获取ins.js和ins.css 有了上面四点准备材料，就大致完成了相册的功能，接下来就一步一步准备所需的材料。 一.获取ins提供的接口数据1.1：获取client Id根据instagram的developer页面，Ins Developer，我们需要首先Register new Client ID,注册客户端可能需要填写手机验证，正常输入验证码即可进入这样的一个页面：按照字面意思填写相应的内容，client id就注册完成了。 1.2：获取token 使用上一步注册好的client id获取token，在浏览器中执行：1https://instagram.com/oauth/authorize/?client_id=&#123;CLIENT_ID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=token 替换两个花括号里面的值，client_id对应上一步获取的id，redirect_uri对应自己注册设定的重定向地址。请求到之后会进入授权界面，授权完毕后会重定向到你设定的redirect_uri地址上面。请注意查看授权后的url，hash部分会附带给你对应的token，到现在为止，你已经成功的获取到了token。 1.3：根据token获取Api 拿到了token，就相当于你有了获取房间内容的钥匙，所以我们根据token去获取对应的api吧：1https://api.instagram.com/v1/users/&#123;USER_ID&#125;/media/recent/?access_token=&#123;TOKEN&#125; 稍等，看这个url，会发现除了token，还需要一个参数：user_id，这又是什么鬼，wf，api里面也到处都是为难开发者的坑呀，但是也不怕，身为资深的程序🐶，这点小问题还是能够解决的吧，我们先试试我们ins账号的user_id：guhuo2424: 恩，我们似乎被骗了吧，为什么给我跳到了404 not found page。。。看来这个user_id非一般的id，还是使用google大法吧： 果然还是有很多这样的神奇网站可供我们使用的，就选择第一个试试看吧： 恩，输入了username和很弱智的验证问题后，终于看到了一个让人激动的期待已久的id，这看来就是我们所需要的，赶紧拿着这个id试试： 不容易呀，终于获得了我们所需要的接口信息。 二.保存json数据和图片第二步开始分析上一步所获取的json数据信息，通过接口数据格式我们发现，每一条ins状态，会对应一条对象数据，里面包含了我们所需的图片地址和对应的状态id，有了这两条数据，我们就可以开始保存对应的数据了。 开始另起一个node项目，实现对json数据的保存和下载对应的缩略图和高清图，具体的代码我已经上传到github上了，这里有跳转链接：Air ticket，请顺便给一个star，谢谢 通过运行node程序后，我们会在source/img/photo目录下面看到保存的对应的图片，其中包含min和正常的图片。在source/_posts/instagram/目录下面看到ins.json文件: 三.静态展示页面在项目的source目录创建一个instagram的文件夹，用作整个相册的入口文件。然后创建index.ejs文件。在其文件内复制下面code：12345678910111213141516171819202122232425262728293031323334353637---layout: postslug: \"photos\"title: \"相册\"noDate: \"true\"comments: \"true\"---&lt;link rel=\"stylesheet\" href=\"./ins.css\"&gt;&lt;div class=\"instagram itemscope\"&gt; &lt;section class=\"archives album\"&gt; &lt;ul class=\"img-box-ul\"&gt; &lt;a href=\"https://www.instagram.com/guhuo2424/\" target=\"_blank\" class=\"open-ins\"&gt;图片来自instagram，正在加载中…&lt;/a&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;&lt;script&gt; function add0(m)&#123;return m&lt;10?'0'+m:m &#125;; function getDate(timeString) &#123; var time = new Date(parseInt(timeString) * 1000); var y = time.getFullYear(); var m = time.getMonth()+1; var d = time.getDate(); return y+'-'+add0(m)+'-'+add0(d); &#125;;&lt;/script&gt;&lt;script&gt; (function() &#123; var loadScript = function(path) &#123; var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) &#125; setTimeout(function() &#123; loadScript('./ins.js') &#125;, 0) &#125;)()&lt;/script&gt; 关于代码头部定义的属性，不熟悉的同学参考：Hexo Document，这段代码的主要意思是创建一个展示图片的页面，js部分实现了一个延迟加载ins.js的脚步，用来拉取并显示图片。 四.获取ins.js和ins.css在上一步获取的node项目中，提供了ins.js和ins.css，将这两个文件放入instagram目录中。其中，js文件大致实现了获取ins.json中的数据，并循环遍历到页面中，具体的实现是在render函数中：1234567891011121314151617181920212223242526var render = function render(res) &#123; var ulTmpl = \"\"; for (var j = 0, len2 = res.data.length; j &lt; len2; j++) &#123; var data = res.data[j]; var liTmpl = \"\"; var minSrc = '/img/photo/' + data.id + '.min.jpg'; var src = '/img/photo/' + data.id + '.jpg'; var type = 'image'; var wrapText = data.caption || &#123;&#125;; var realText = wrapText.text || \"么么哒~~\"; liTmpl += '&lt;figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\"&gt;\\ &lt;a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"640x640\" data-type=\"' + type + '\" data-target=\".jpg\"&gt;\\ &lt;img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"'+ minSrc +'\" itemprop=\"thumbnail\" onload=\"lzld(this)\"&gt;\\ &lt;h1 class=\"year\"&gt;'+ getDate(data.created_time) +'&lt;/h1&gt;\\ &lt;/a&gt;\\ &lt;figcaption style=\"display:none\" itemprop=\"caption description\"&gt;' + realText + '&lt;/figcaption&gt;\\ &lt;/figure&gt;'; ulTmpl = ulTmpl + liTmpl; &#125; document.querySelector('.img-box-ul').innerHTML = '&lt;div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\"&gt;' + ulTmpl + '&lt;/div&gt;'; createVideoIncon(); _view2.default.init(); &#125;; 最后，所有的准备工作就处理完成了，我们在themes/yilia/_config.yml的配置文件里面配置入口：123menu: 主页: / 相册: /instagram/ 使用hexo server启动本地调试，看看我们最终实现的效果吧，是不是很激动呢。 感言步骤还是很繁琐的，只有耐着性子的做完，才能看到最终的果实。身为程序员的我们，也必须拥有这样的耐性，去一步一步的尝试，即使失败，也会无憾。 也非常感谢有ins这样的好的社交网站，给我们提供这些技术，相比于国内的社交网站，真的很缺少分享技术的意识，这应该就是社交产品真正的灵魂吧，让每个人都能够实现自己想要的效果。 至此，这篇文章就分享结束啦，有不懂得同学可以下面留言。 另外，很重要很重要很重要的是：给nodejs-ins的github项目一个Star✨，非常非常非常感激。 转载请注明原地址，luojh的博客：http://luojh.me 谢谢！ 如果对你有用，请赞赏一个吧","tags":[{"name":"Blog","slug":"Blog","permalink":"http://www.luojh.me/tags/Blog/"},{"name":"教程","slug":"教程","permalink":"http://www.luojh.me/tags/教程/"},{"name":"相册","slug":"相册","permalink":"http://www.luojh.me/tags/相册/"}]},{"title":"React-Native开发之原生回调RN发送消息","date":"2017-08-07T06:20:25.000Z","path":"2017/08/07/reactNative/reactNativeSendEvent2/","text":"RN和原生之间的消息传递,方法在上期介绍了三种,并且详细的介绍了其中的一种,即原生向RN发送事件传递消息,另外还有另外两种方式是通过RN向原生请求数据。在今天的这篇文章里面,就好好聊聊这两种情况。 回顾:在rn官网,可以看到关于原生模块(android)向rn发送消息,即原生与rn相通信,FB实现了自己的一套交互体系: 使用回调函数Callback，它提供了一个函数来把返回值传回JavaScript 使用Promise来实现 RCTDeviceEventEmitter 事件方式三种方式各具有不同的优缺点: 方式 优点 缺点 Callback js调用，Native返回 CallBack为异步操作，原生还在执行操作时,callback已经执行了,返回时机不确定 Promise JS调用，Native返回 每次使用需要JS调用一次 RCTDeviceEventEmitter 可任意时刻传递，Native主导控制 无 开始:这篇文章主要介绍通过Promise方式给RN回调对应的数据,Promise是一种很常见的传递数据的方式,在rn端微信,支付宝支付,分享等功能,都应用了Promise进行传递数据。所以,很有必要好好深入研究一下,从而自己能够实现对原生SDK的操作。 PromisePromise 是 ES6 中增加的对于异步编程和回调更加友好的 API。原生模块是在 com.facebook.react.bridge 中定义的 Promise 接口，实现了 resolve 和 reject 方法，resolve 用来处理正确结果，reject 用来处理异常。1234567891011121314151617181920//要导出一个方法给 JavaScript 使用，Java 方法需要使用注解 @ReactMethod，方法的返回类型必须为 void@ReactMethodpublic void login(String name, String password, Promise promise) &#123; try &#123; if (TextUtils.isEmpty(name)) &#123; promise.reject(\"-1\", \"name is empty\"); return; &#125; if (new LoginTask().login(name, password)) &#123; WritableMap map = Arguments.createMap(); map.putString(\"name\", name); promise.resolve(map); &#125; else &#123; promise.reject(\"-3\", \"login failure\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); promise.reject(e); &#125;&#125; 在 JavaScript 中可以这样调用:1234567891011NativeModules.LoginModule.login('name', 'password') .then( (map) =&gt; &#123; alert(map.name) &#125; ) .catch( (code, err) =&gt; &#123; alert(err) &#125; ) 或者用 async/await 来修饰，以同步方式调用原生模块:123456789async login() =&gt; &#123; try &#123; let &#123; ame &#125; = await NativeModules.LoginModule.login('name', 'password'); console.log(name); &#125; catch (code, err) &#123; alert(err) &#125;&#125; CallbackCallback 是 com.facebook.react.bridge 中的一个接口，作为 ReactMethod 的一个传参，用来映射 JavaScript 的回调函数（function）。Callback 接口只定义了一个方法 invoke，invoke 接受多个参数，这个参数必须是 com.facebook.react.bridge 中支持的参数。1234567891011121314151617@ReactMethodpublic void login(String name, String password, Callback success, Callback failure) &#123; try &#123; if (TextUtils.isEmpty(name)) &#123; failure.invoke(\"name is empty\"); return; &#125; if (new LoginTask().login(name, password)) &#123; success.invoke(name); &#125; else &#123; failure.invoke(\"login failure\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); failure.invoke(e.getMessage()); &#125;&#125; 在 JavaScript 中可以这样调用12345NativeModules.LoginModule.login('name', 'password', (name) =&gt; &#123; alert(name) &#125;, (err) =&gt; &#123; alert(err) &#125;) 恩。。。今天的分享就是这些啦,有疑问可以在评论处留言。分享三篇相关博文: React Native基于最新版本实现JsBundle预加载，解决白屏等待，界面秒开优化。传送门 React Native与Android通信交互 传送门 Android布局加载React Native视图 传送门","tags":[{"name":"android","slug":"android","permalink":"http://www.luojh.me/tags/android/"},{"name":"React-Native","slug":"React-Native","permalink":"http://www.luojh.me/tags/React-Native/"}]},{"title":"React-Native开发之原生模块向JavaScript发送事件","date":"2017-08-02T07:20:25.000Z","path":"2017/08/02/reactNative/reactSendEvent/","text":"JavaScript端接收来自原生模块发送的事件，实现了前端与原生模块之间的通信本品博文的内容主要介绍的是原生安卓向js发送事件,并传递消息给react-native。在rn官网,可以看到关于原生模块(android)向rn发送消息,即原生与rn相通信,FB实现了自己的一套交互体系: 使用回调函数Callback，它提供了一个函数来把返回值传回JavaScript 使用Promise来实现 RCTDeviceEventEmitter 事件方式三种方式各具有不同的优缺点: 方式 优点 缺点 Callback js调用，Native返回 CallBack为异步操作，原生还在执行操作时,callback已经执行了,返回时机不确定 Promise JS调用，Native返回 每次使用需要JS调用一次 RCTDeviceEventEmitter 可任意时刻传递，Native主导控制 无 前两种方式相对于原生模块来说,是一种较为被动的方式,但是第三种则是比较主动的机制,当原生执行到任何一步时,都可以主动地给rn发送消息。前端则需要监听该事件,当前端收到某确定事件时，则可准确获知原生函数目前执行的状态以及得到原生函数的返回值等。这样前端可以进行下一步的操作，如更新UI等。 接下来我们看一下如何由原生模块向JavaScript前端发送事件: 1.首先你需要定一个发送事件的方法,如代码所示:12345678910//Demo.javapublic class Demo &#123; public static ReactContext myContext; public void sendEvent(ReactContext reactContext, String eventName, String params) &#123; reactContext .getJSMo`dule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(eventName, params); &#125; &#125; 其中方法名可以任意，但是参数不可改变。该方法可以放在你要复用的原生类中（demo将定义一个原生类Demo在Demo.java文件中）需要注意的是，由于版本问题，该函数中的参数reactContext有可能为null，此时会报NullPointException的错误。所以我们需要手动给reactContext赋值，见步骤2. 2.获取reactContext的值我们在原生类Demo中，定义变量public static ReactContext MyContext,然后在我们自定义的继承至ReactContextBaseJavaModule的类中给reactContext赋值。1234567891011public class MyModule extends ReactContextBaseJavaModule &#123; public MyModule(ReactApplicationContext reactContext) &#123; super(reactContext); Demo.MyContext=reactContext; &#125; //以下写被@ReactNative所标注的方法 ...&#125; 此时，reactContext将不会是null。也就不会报错。 3.在原生类中向RN发送事件1234// myContext是当前的上下文,即上边步骤定义的变量// 第二个参数代表事件变量名,需要在rn端用到// 第三个参数代表需要传递的数据sendEvent(myContext, \"pushData\", \"这里是你想要发送的数据,可以是任何数据类型的字符串格式\"); 4.在RN端进行监听在RN前端监听事件。首先导入DeviceEventEmitter，即:import{ DeviceEventEmitter } from &#39;react-native&#39;,然后使用componentWillMount建立监听。123DeviceEventEmitter.addListener('pushData', function (msg) &#123; ToastAndroid.show(\"DeviceEventEmitter收到消息:\" + \"\\n\" + msg, ToastAndroid.SHORT)&#125;); 条理还是很清晰吧,下面提供一个完整的Demo,功能如下:（1）JavaScript端在监听一个事件。（2）点击前端某行文字，调用原生方法。（3）在原生方法中，延迟3s后向前端发送对应事件。（4）前端接收到事件后，给出alert提示。 ManiActivity.Java123456789101112131415package com.luojh; import com.facebook.react.ReactActivity; public class MainActivity extends ReactActivity &#123; /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() &#123; return \"luojh\"; &#125; &#125; ManiApplication.java123456789101112131415161718192021222324252627282930313233343536package com.luojh; import android.app.Application; import android.util.Log; import com.facebook.react.ReactApplication; import com.facebook.react.ReactInstanceManager; import com.facebook.react.ReactNativeHost; import com.facebook.react.ReactPackage; import com.facebook.react.shell.MainReactPackage; import java.util.Arrays; import java.util.List; public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new MyPackage() ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125; &#125; MyModule.java12345678910111213141516171819202122232425262728293031package com.luojh; import com.facebook.react.bridge.ReactApplicationContext; import com.facebook.react.bridge.ReactContextBaseJavaModule; import com.facebook.react.bridge.ReactMethod; /** * Created by Administrator on 2016/10/30. */ public class MyModule extends ReactContextBaseJavaModule &#123; public MyModule(ReactApplicationContext reactContext) &#123; super(reactContext); //给上下文对象赋值 Test.myContext=reactContext; &#125; @Override public String getName() &#123; return \"MyModule\"; &#125; @ReactMethod public void NativeMethod() &#123; //调用Test类中的原生方法。 new Test().fun(); &#125; &#125; MyPackage.java123456789101112131415161718192021222324252627282930313233343536package com.luojh; import com.facebook.react.ReactPackage; import com.facebook.react.bridge.JavaScriptModule; import com.facebook.react.bridge.NativeModule; import com.facebook.react.bridge.ReactApplicationContext; import com.facebook.react.uimanager.ViewManager; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * Created by Administrator on 2016/10/30. */ public class MyPackage implements ReactPackage &#123; @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules=new ArrayList&lt;&gt;(); modules.add(new MyModule(reactContext)); return modules; &#125; @Override public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() &#123; return Collections.emptyList(); &#125; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125; &#125; Test.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ywq; import android.provider.Settings; import android.support.annotation.Nullable; import com.facebook.react.bridge.Arguments; import com.facebook.react.bridge.ReactContext; import com.facebook.react.bridge.WritableMap; import com.facebook.react.modules.core.DeviceEventManagerModule; /** * Created by Administrator on 2016/10/30. */ public class Test &#123; //定义上下文对象 public static ReactContext myContext; //定义发送事件的函数 public void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) &#123; System.out.println(\"reactContext=\"+reactContext); reactContext .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(eventName,params); &#125; public void fun() &#123; //在该方法中开启线程，并且延迟3秒，然后向JavaScript端发送事件。 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //发送事件,事件名为EventName WritableMap et= Arguments.createMap(); sendEvent(myContext,\"EventName\",et); &#125; &#125;).start(); &#125; &#125; 前端index.Android.js代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123; Component &#125; from 'react'; import &#123; AppRegistry, StyleSheet, Text, DeviceEventEmitter, NativeModules, View &#125; from 'react-native'; export default class Luojh extends Component &#123; componentWillMount() &#123; //监听事件名为EventName的事件 DeviceEventEmitter.addListener('EventName', () =&gt; &#123; alert(\"send success\"); &#125;); &#125; constructor(props) &#123; super(props); this.state = &#123; content: '这个是预定的接受信息', &#125; &#125; callNative() &#123; NativeModules.MyModule.NativeMethod(); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125; onPress=&#123;this.callNative.bind(this)&#125; &gt; 当你点我的时候会调用原生方法，原生方法延迟3s后会向前端发送事件。 前端一直在监听该事件，如果收到，则给出alert提示! &lt;/Text&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; &#123;this.state.content&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent('luojh', () =&gt; Luojh); 至此,今天的教程到这里就结束了,大家有什么疑问,可以在评论中留言。","tags":[{"name":"android","slug":"android","permalink":"http://www.luojh.me/tags/android/"},{"name":"React-Native","slug":"React-Native","permalink":"http://www.luojh.me/tags/React-Native/"}]},{"title":"MAC安装和配置android-sdk","date":"2017-07-19T08:20:25.000Z","path":"2017/07/19/reactNative/initAndroidSdk/","text":"在MAC上安装android-sdk，标准的安装方法是使用homebrew 安装运行如下命令：brew updatebrew install android-sdk如果遇到无法通过代理下载安装包的情况时，可以先手动下载安装包，然后，将安装包放到homebrew的缓存里$ cp &lt;path to download file&gt; $(brew --cache android-sdk) 再执行 $ brew install android-sdk 这样，就可以成功安装android-sdk了。 配置1、配置.bash_profile，如果使用的是Oh-My-Zsh，则配置.zshrc，在文件的结尾加上下面这句： export ANDROID_HOME=&quot;/usr/local/opt/android-sdk&quot; 然后source ~/.zshrc使其生效 2、安装辅助包 运行android命令，调出Android SDK Manager，安装下面这些选项： Tools Android SDK Tools Android SDK Platform-tools Android SDK Build-tools Android 5.1.1 (API 22) SDK Platform Intel x86 Atom_64 System Image Extras Android Suport Library Intel x86 Emulator Accelerator(HAXM Installer) 3、安装HAXM(Hardware_Accelerated_Execution_Manager) 进入以下目录 $ cd /usr/local/Cellar/android-sdk/24.4.1_1/extras/intel/Hardware_Accelerated_Execution_Manager/ 然后安装HAXM $ ./HAXM\\ installation 就这样，android模拟器就安装好了。 配置模拟器运行以下命令： $ android avd 打开Android Virtual Device Manager 选择Device Definitions一项 选择需要的模拟器类型，点击Create AVD 创建完成AVD之后，回到Android Virtual Devices选项卡，选择创建好的模拟器，点击Start就可以启动模拟器了。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.luojh.me/tags/nodejs/"},{"name":"android","slug":"android","permalink":"http://www.luojh.me/tags/android/"}]},{"title":"CSS3之Grid布局","date":"2017-07-13T04:20:25.000Z","path":"2017/07/13/css/css-grid-layout/","text":"CSS Grid布局出来已经很久了,在今年3月份正式得到所有浏览器的支持,也正因为此,今后的html布局也将要以grid布局为基础,进行开发。它是继flexbox布局之后又一个强大的布局系统,可以完成flexbox布局完成不了的复杂,智能,响应式布局。所以,很有必要去认真的学习一下。 专业术语在学习这个属性之前,很有必要熟悉一下对应这个属性的一些专业术语,在整个网格中常用的术语有: 网格线(Grid lines) 水平或纵向网格轨道(Grid tracks) 行(Rows) 列(Columns) 间距(Gutters) 轨道行和列之间的间距 单元格(Grid cells) 轨道相交产生的内容区域,相当于table中的单元格1表示Grid lines, 2表示Columns, 3表示Rows, 4表示Cells 间距对于网格布局,两个轨道之间的区域称之为间距(gutters) 网格区域(Grid area)网格区域是由任何四个网格线组成的区域，它可以包含任意数量的网格单元格。 相信这些术语能够更好地帮组我们理解Grid布局,接下来花点时间让我们创建一个网格，并且在浏览器能看到其效果。 网格容器通过设置css属性display: grid或者display: inline-grid可以创建一个网格容器,网格容器中的所有子元素就会自动变成网格项目(grid item)网格项目默认放在行中,并且跨网格容器的全宽,在codePen中切换grid Or inline-grid 进行体验。 See the Pen vZPYQv by Leojh (@LeoJingHui) on CodePen. column, float, clear, 和 vertical-align 元素对网格容器不起作用。 接下来需要定义网格样式风格,也就是设置网格行和列,我们可以通过grid-template-columns和grid-template-rows来设置。 属性1: grid-template-rows | grid-template-columns : 利用以空格分隔的值定义网格的列和行。值的大小代表轨道的大小，并且它们之间的空格表示网格线。12345.container &#123; display: grid; grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ... | subgrid; grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ... | subgrid;&#125; track-size: 可以是一个长度、百分比或者是网格中自由空间的一小部分(使用fr单位)line-name: 你选择的任意名称subgrid: 如果你的网格容器本身就是一个网格项(即嵌套网格)，你可以使用此属性指定行和列的大小继承于父元素而不是自身指定。示例:当你在值之间留有空格时，网络线就会自动分配数值名称:1234.container&#123; grid-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto;&#125; 但是你也可以显示命名，请参考下面括号语法中的名称命名方式:123456.grid &#123; display: grid; height: 300px; grid-template-rows: [row1-start] 20% [row1-end] 40% [third-line] auto [last-line]; grid-template-columns: repeat(3, 20% [row1-end]) 1fr;&#125; See the Pen EXMjPB by Leojh (@LeoJingHui) on CodePen.请注意，一条网格线可以具有有多个名称。例如，这里的第二行将有两个名字: row1-end 和 row2-start如果你的定义中包含重复的部分，你可以使用 repeat() 表示法进行精简:1grid-template-columns: repeat(3, 20% [row1-end]) 1fr; 等效于:1grid-template-columns: 20% [row1-end] 20% [row1-end] 20% [row1-end] 1fr; fr 单位允许你将一个轨道大小设置为网格容器内自由空间的一小部分。如下所示，每个网格项就会占据网格容器宽度的三分之一:123.container&#123; grid-template-columns: 1fr 1fr 1fr;&#125; 这里自由空间表示除去非弹性项以后剩余的空间。在此示例中的 fr 单位的可用空间表示减去50px以后的空间大小:123.container&#123; grid-template-columns: 1fr 50px 1fr 1fr;&#125; 属性2: grid-template-areas :","tags":[{"name":"css3","slug":"css3","permalink":"http://www.luojh.me/tags/css3/"},{"name":"grid-layout","slug":"grid-layout","permalink":"http://www.luojh.me/tags/grid-layout/"}]},{"title":"Node.js之async-await使用","date":"2017-04-18T08:20:25.000Z","path":"2017/04/18/nodejs/nodejs-async/","text":"Node.js 7 night中引入了async/await用法，但是在Node.js 8和Javascript V8才可能正式激活async/await函数。 what’s asyncJavaScript 里面处理异步调用一直是非常恶心的一件事情。以前只能通过回调函数，后来渐渐又演化出来很多方案，最后 Promise 以简单、易用、兼容性好取胜，但是仍然有非常多的问题。其实 JavaScript 一直想在语言层面彻底解决这个问题，在 ES6 中就已经支持原生的 Promise，还引入了 Generator 函数，终于在 ES7 中决定支持 async 和 await。 基本语法async/await 究竟是怎么解决异步调用的写法呢？简单来说，就是将异步操作用同步的写法来写。先来看下最基本的语法（ES7 代码片段）：1234567891011121314const f = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(123); &#125;, 2000); &#125;);&#125;;const testAsync = async () =&gt; &#123; const t = await f(); console.log(t);&#125;;testAsync(); 首先定义了一个函数 f ，这个函数返回一个 Promise ，并且会延时 2 秒， resolve 并且传入值 123 。 testAsync 函数在定义时使用了关键字 async ，然后函数体中配合使用了 await ，最后执行 testAsync 。整个程序会在 2 秒后输出 123 ，也就是说 testAsync 中常量 t 取得了 f 中 resolve 的值，并且通过 await 阻塞了后面代码的执行，直到 f 这个异步函数执行完。 对比 Promise123456789101112131415const f = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(123); &#125;, 2000); &#125;);&#125;;const testAsync = () =&gt; &#123; f().then((t) =&gt; &#123; console.log(t); &#125;);&#125;;testAsync(); 下面案例是展示如何使用Promise和Fetch API抓取数据的：123456789function getTrace () &#123; return fetch('http://www.luojh.me', &#123; method: 'get' &#125;)&#125;getTrace() .then() .catch() 异常处理使用async/await，能以非堵塞方式暂停执行，一直等待结果返回，如果promise返回的是拒绝不成功，拒绝值将抛出，能够被try/catch捕获。上面案例可使用async/await写成如下：12345678910111213function async getTrace () &#123; let pageContent try &#123; pageContent = await fetch('https://www.jdon.com', &#123; method: 'get' &#125;) &#125; catch (ex) &#123; console.error(ex) &#125; return pageContent&#125;getTrace().then(); 如果 try 范围内包含多个 await ，那么 catch 会返回第一个 reject 的值或错误。 async使用async读取文件：123456789101112131415161718var fs = require('fs');var readFile = () =&gt; (new Promise((resolve, reject) =&gt; &#123; fs.readFile(__dirname + '/test.txt', &#123;flag: 'r+', encoding: 'utf8'&#125;, (err,data) =&gt; &#123; if(err) &#123; reject(); console.log(err); return ; &#125; resolve(data); &#125;)&#125;));(async () =&gt; &#123; let files = await readFile(); console.log('result: ' + files);&#125;)(); Note如果不能运行，可能是nodejs是nightly版本，未正式支持 async/await，命令行该为：1node --harmony-async-await app.js","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.luojh.me/tags/nodejs/"},{"name":"nodejs-fs","slug":"nodejs-fs","permalink":"http://www.luojh.me/tags/nodejs-fs/"}]},{"title":"Node.js的文件系统Api","date":"2017-04-17T08:20:25.000Z","path":"2017/04/17/nodejs/nodejs-fs/","text":"Node.js的文件系统fs的Api123//公共引用var fs = require('fs'),path = require('path'); 1、读取文件readFile函数1234567891011121314151617181920212223242526272829303132333435//readFile(filename,[options],callback);/** * filename, 必选参数，文件名 * [options],可选参数，可指定flag（文件操作选项，如r+ 读写；w+ 读写，文件不存在则创建）及encoding属性 * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据 */var fs = require('fs');// fs.readFile(__dirname + '/test.txt', &#123;flag: 'r+', encoding: 'utf8'&#125;, function (err, data) &#123;// if(err) &#123;// console.error(err);// return;// &#125;// console.log(data);// &#125;);//es7 async写法var readFile = () =&gt; (new Promise((resolve, reject) =&gt; &#123; fs.readFile(__dirname + '/test.txt', &#123;flag: 'r+', encoding: 'utf8'&#125;, (err,data) =&gt; &#123; if(err) &#123; reject(); console.log(err); return ; &#125; resolve(data); &#125;)&#125;));(async () =&gt; &#123; let files = await readFile(); console.log('result: ' + files);&#125;)(); 2、写文件123456789101112131415161718// fs.writeFile(filename,data,[options],callback);var w_data = '这是一段通过fs.writeFile函数写入的内容；\\r\\n';var w_data = new Buffer(w_data);/** * filename, 必选参数，文件名 * data, 写入的数据，可以字符或一个Buffer对象 * [options],flag,mode(权限),encoding * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据 */fs.writeFile(__dirname + '/test.txt', w_data, &#123;flag: 'a'&#125;, function (err) &#123; if(err) &#123; console.error(err); &#125; else &#123; console.log('写入成功'); &#125;&#125;); 3、以追加方式写文件12345// fs.appendFile(filename,data,[options],callback);fs.appendFile(__dirname + '/test.txt', '使用fs.appendFile追加文件内容', function () &#123; console.log('追加内容完成');&#125;); 4、打开文件123456789101112// fs.open(filename, flags, [mode], callback);/** * filename, 必选参数，文件名 * flags, 操作标识，如\"r\",读方式打开 * [mode],权限，如777，表示任何用户读写可执行 * callback 打开文件后回调函数，参数默认第一个err,第二个fd为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄 */fs.open(__dirname + '/test.txt', 'r', '0666', function (err, fd) &#123; console.log(fd);&#125;); 5、创建目录1234567891011121314//使用fs.mkdir创建目录//fs.mkdir(path, [mode], callback);/** * path, 被创建目录的完整路径及目录名； * [mode], 目录权限，默认0777 * [callback(err)], 创建完目录回调函数,err错误对象 */fs.mkdir(__dirname + '/fsDir', function (err) &#123; if(err) throw err; console.log('创建目录成功')&#125;); 6、查看文件与目录的是否存在1234567891011//fs.exists(path, callback);/** * path, 要查看目录/文件的完整路径及名； * [callback(exists)], 操作完成回调函数；exists true存在，false表示不存在 */fs.exists(__dirname + '/te', function (exists) &#123; var retTxt = exists ? retTxt = '文件存在' : '文件不存在'; console.log(retTxt);&#125;); 7、修改文件访问时间与修改时间12345678910111213141516171819//fs.utimes(path, atime, mtime, callback);/** * path, 要查看目录/文件的完整路径及名； * atime, 新的访问时间 * ctime, 新的修改时间 * [callback(err)], 操作完成回调函数；err操作失败对象 */fs.utimes(__dirname + '/test.txt', new Date(), new Date(), function (err) &#123; if(err) &#123; console.error(err); return; &#125; fs.stat(__dirname + '/test.txt', function (err, stat) &#123; console.log('访问时间: ' + stat.atime.toString() + '; \\n修改时间：' + stat.mtime); console.log(stat.mode); &#125;)&#125;); 8、创建读取流1234567891011121314151617181920212223242526272829303132333435363738394041//fs.createReadStream(path, [options])/** * path 文件路径 * [options] flags:指定文件操作，默认'r',读操作；encoding,指定读取流编码；autoClose, 是否读取完成后自动关闭，默认true；start指定文件开始读取位置；end指定文件开始读结束位置 */var rs = fs.createReadStream(__dirname + '/test.txt', &#123;start: 0, end: 2&#125;); //open是ReadStream对象中表示文件打开时事件，rs.on('open', function (fd) &#123; console.log('开始读取文件');&#125;);rs.on('data', function (data) &#123; console.log(data.toString());&#125;);rs.on('end', function () &#123; console.log('读取文件结束')&#125;);rs.on('close', function () &#123; console.log('文件关闭');&#125;);rs.on('error', function (err) &#123; console.error(err);&#125;);//暂停和回复文件读取；rs.on('open', function () &#123; console.log('开始读取文件');&#125;);rs.pause();rs.on('data', function (data) &#123; console.log(data.toString());&#125;);setTimeout(function () &#123; rs.resume();&#125;, 2000);","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.luojh.me/tags/nodejs/"},{"name":"nodejs-fs","slug":"nodejs-fs","permalink":"http://www.luojh.me/tags/nodejs-fs/"}]},{"title":"React-Native踩过的坑---分享篇","date":"2017-03-17T08:20:25.000Z","path":"2017/03/17/reactNative/reactNativeError/","text":"年前开发React-native没有做分享,这几天在完善整个App,记录一下分享功能的一些坑。 错误信息:12com.android.build.api.transform.TransformException: java.util.zip.ZipException:duplicate entry: com/tencent/mm/sdk/a/a$a.class 是由于微信和umeng重复的引入相同的jar包引起的,解决方法是: 在项目根目录搜索SocialSDK_WeiXin_1.jar,删除此jar包即可。 错误信息:12345UNEXPECTED TOP-LEVEL EXCEPTION:com.android.dex.DexException: Multiple dex files define Landroid/support/v7/appcompat/R$anim;Execution failed for task &apos;:app:dexDebug&apos;.&gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/bin/java&apos;&apos; finished with non-zero exit value 2 未知原因,google了好久,终于在我大神奇github网站的某一篇文章中找到了解决方法。只需要在项目根目录,执行命令:1cd android &amp;&amp; ./gradlew clean 错误信息：1234567** BUILD FAILED **The following build commands failed: CompileC /Users/tveloso/Library/Developer/Xcode/DerivedData/ABC-dbvlmexxbrkpqubvzgqzuzdlxptp/Build/Intermediates/Pods.build/Debug-iphoneos/Pods-ABC-Realm.build/Objects-normal/armv7/external_commit_helper.o Realm/Realm/ObjectStore/impl/apple/external_commit_helper.cpp normal armv7 c++ com.apple.compilers.llvm.clang.1_0.compiler(1 failure)None 解决方法：Simply switch off Enable Modules (C and Objective-C) in the target for ‘Realm’. 错误信息：1RCTRootView.h file not found 如果确定文件一定安装，那么请尝试以下方法： 需要把 Building Setting 里的Header Search Paths属性的值 “${PODS_ROOT}/Headers/Public/React” - not-recursive 改为 recursive 就可以了，由于Pods里的React结构改变了，但配置没有改过来，所以出现找不到文件的问题。 错误信息：123&apos;React/RCTBridgeModule.h&apos; file not foundorfatal error: &apos;React/RCTBridgeModule.h&apos; #390 解决方法： Open ios/[project-name].xcodeproj with XCode In the left panel (Project Navigator), navigate to Libraries/RNVectorIcons.xcodeproj/RNVectorIconsManager In RNVectorIconsManager.h and RNVectorIconsManager.m, remove the React/ prefix from all includes, for example: #import &lt;React/RCTConvert.h&gt; =&gt; #import &lt;RCTConvert.h&gt; 报错信息：1RCTBridgeModule.h&apos; file not found 解决方法：change RCTWebChat.xcodeproj → Build Settings → Search Paths → Header Search Paths to$(SRCROOT)/../../react-native/React and$(SRCROOT)/../../react-native/Libraries 中间陆续也踩了好多坑哎,最后实现了效果。","tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.luojh.me/tags/react-native/"},{"name":"react-native-wechat","slug":"react-native-wechat","permalink":"http://www.luojh.me/tags/react-native-wechat/"}]},{"title":"Canvas贝塞尔曲线总结","date":"2017-03-07T08:20:25.000Z","path":"2017/03/07/html/canvas1/","text":"最近在学习canvas,记录一下贝塞尔曲线的两个使用方法: quadraticCurveTo(); bezierCurveTo(); 定义和用法quadraticCurveTo() 方法通过使用表示二次贝塞尔曲线的指定控制点，向当前路径添加一个点。提示：二次贝塞尔曲线需要两个点。 第一个点是用于二次贝塞尔计算中的控制点。 第二个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。 如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 开始点：moveTo(20,20) 控制点：quadraticCurveTo(20,100,200,20) 结束点：quadraticCurveTo(20,100,200,20) 语法1context.quadraticCurveTo(cpx,cpy,x,y); 参数值 参数 描述 cpx 贝塞尔控制点的 x 坐标 cpy 贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 定义和用法bezierCurveTo() 方法通过使用表示三次贝塞尔曲线的指定控制点，向当前路径添加一个点。提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 开始点：moveTo(20,20) 控制点 1：bezierCurveTo(20,100,200,100,200,20) 控制点 2：bezierCurveTo(20,100,200,100,200,20) 结束点：bezierCurveTo(20,100,200,100,200,20) 语法1context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); 参数值 参数 描述 cp1x 第一个贝塞尔控制点的 x 坐标 cp1y 第一个贝塞尔控制点的 y 坐标 cp2x 第二个贝塞尔控制点的 x 坐标 cp2y 第二个贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实践基本语法学习完了,就开始自己动手画图啦。首先,来个简单一点的,两个C字母组合吧:12345678910111213141516context.lineWidth = 5;context.strokeStyle = &quot;green&quot;;context.moveTo(50, 50);context.bezierCurveTo(50, 50, 150, 50, 150, 150);context.stroke();context.quadraticCurveTo(150, 250, 50, 250);context.stroke();context.beginPath();context.strokeStyle = &quot;red&quot;;context.moveTo(260, 50);context.quadraticCurveTo(155, 50, 155, 155);context.stroke();context.bezierCurveTo(155, 155, 155, 250, 250, 250);context.stroke(); 效果如图: 恩,感觉还不错,接着画一个😊的表情吧:1234567891011121314151617context.beginPath();context.lineCap = &quot;round&quot;;context.strokeStyle = &quot;black&quot;;context.moveTo(300, 80);context.quadraticCurveTo(312, 40, 360, 50);context.stroke();context.moveTo(500, 80);context.quadraticCurveTo(490, 40, 445, 50);context.stroke();context.beginPath();context.lineJoin = &quot;round&quot;;context.moveTo(340, 150);context.quadraticCurveTo(405, 230, 470, 150);context.quadraticCurveTo(405, 200, 340, 150);context.stroke(); 丑到爆的微笑表情😔,耐着性子看吧~~至此,Canvas简单的曲线方法使用就结束了,也是难以理解,只有一步一步的写例子,才能加深理解,这就是个人的学习方式吧。","tags":[{"name":"canvas","slug":"canvas","permalink":"http://www.luojh.me/tags/canvas/"},{"name":"html","slug":"html","permalink":"http://www.luojh.me/tags/html/"}]},{"title":"2017-岂止于心","date":"2017-02-10T04:20:25.000Z","path":"2017/02/10/books/","text":"16年毕业后,工作到现在也已经一年有余,从一个不懂世俗的单纯小子到步入职场的小骚年,身份却没有来的及转换过来,导致16年生活,工作安排的混乱不堪,幸得公司年假放了20天有余,得以在这些天内,沉静下来,理清现状,思考如何改变。所以,2017年有了下列计划: 读书,填充头脑 解忧杂货铺 【东野圭吾】 白夜行 【东野圭吾】 猫鼠游戏 [弗兰克·W·阿巴格内尔/斯坦·雷丁(著)] ReactNative跨平台移动应用开发 【阙喜涛】 世界上的另一个你全集 平凡的世界 人生 【路遥】 与时间做朋友 【李笑来】 深入React技术栈 【陈屹】 Js函数式编程 三体全集(ing)[刘慈欣] 我们仨 无声告白 人类简史:从动物到上帝 岛上书店 如何闻读一本书 总控力 查令十字街84号 嫌疑人X的现身 追风筝的人 牛奶可乐经济学 最好的我们 天才在左疯子在右 把你的英语用起来 把时间当朋友 围城 乌合之众 跟任何人都能聊得来 耶路撒冷三千年 偷影子的人 苏菲的世界 了不起的盖茨比 不速之客的自助餐 活着 当我跑步时,我谈些什么 时间简史(插图版) 金瓶梅 魔鬼经济学: 揭示隐藏在表象之下的真实世界 必然 影响力 一直特立独行的猪 局外人 目送 秘密 悟空传 拖延心理学 经济学通识 像TED一样演讲 我讲个笑话,你可别哭啊 1984 爱你就像爱生命 你只是看起来很努力 上述52本书籍,挑选了来自于Kindle2016Top100里面的其中一部分,其中包含了,技术,文学,经济,心理,科技等多个种类的书籍,幸好我对于书籍没有抵触心理,在过年的那段时间内,我陆续读完了5本书,这也培养了我在空闲时间内去读书的习惯,也一定要继续坚持下去,争取年内把这些书都读完。 备注: 中划线的是看完的,其余的按照心情选择阅读。 画画虽然那么喜欢油彩画,但是在考虑学习成本,空间,时间后,选择以色铅简笔画为基础,培养兴趣的学习绘画,已达到静心养性的最高心里境界吧。罗列两三本正在学的简笔画书籍,有兴趣的可以一块学,一块交流,后期附上我的作品啦,哈哈哈 色铅笔技法从入门到精通 色铅笔手绘纯美人像 Free在懒散之余,练习硬笔书法,魔方,瑜伽。后期会附上我的魔方教学帖子,供以后回忆~~ 总结总的来说,新的一年,总是要努力一下,与其碌碌无为,不如平心而为,做些有趣的事情,提升自己。毕竟,我和小米都:永远相信美好的事情，即将发生。 一生最重 不过饱餐与被爱","tags":[{"name":"Book","slug":"Book","permalink":"http://www.luojh.me/tags/Book/"}]},{"title":"Hexo搭建个人博客-初始化","date":"2017-02-08T04:20:25.000Z","path":"2017/02/08/blog1/","text":"过完新年,在公司闲来无事,便索性想搭建自己的博客系统,其实这个想法很早就有了,不过16年太过于忙碌,生活工作节奏太乱,没有好好沉静,反思和沉淀。其实好多事情,在没有经历过,会觉得那些东西看起来如此牛逼,但是真正经历了,自己做了之后,会发现,牛逼的不仅是那些事,还有自己~~此篇教程是纪念我花费在博客上面的所有逝去的时间🌺 ,并且帮助那些想要建立博客的同学们☀️。那么,现在直接奉上搭建步骤: Hexo? Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 大致解释是:Hexo是一个快速，简单和强大的博客框架。你写的Markdown（或其他语言）的帖子Hexo在几秒钟内就能生成静态文件; 环境配置安装Hexo非常容易。但是，你需要先安装几个其他的东西： Node.js作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。官网入口 Github账号作用：用来做博客的远程创库、域名、静态资源服务器。怎么申请github的账号和ssh key等,请大家自行搜索,网络上资源还是很丰富的。 正式安装Hexonodejs和git都安装好后，可执行如下命令安装hexo：1sudo npm install -g hexo 初始化创建一个文件夹，如：Blog，进入到Blog里分别执行init命令和安装依赖命令：12hexo initnpm install 生成静态页面继续再Blog目录下执行如下命令，生成静态页面:1hexo generate （hexo g 也可以） 安装hexo-server插件1sudo npm install hexo-server 本地启动启动本地服务，进行文章预览调试，命令：1hexo server (hexo s 也可以) 浏览器输入localhost:4000进行预览博客网站,是不是很简陋呢,但是好歹有一个自己的家园了,也是很兴奋呢。但是现在都是在本地进行的,需要和github进行关联。 配置Github建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联,例如我的是:luojinghui.github.io,此时,你的目录应该是这样子: Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要修改_config.yml文件，用编辑器打开,翻到最后,改成这个样子(注意冒号后面的空格): 1234deploy: type: git repository: https://github.com/luojinghui/luojinghui.github.io branch: master 执行如下命才能使用git部署(只需要执行一次): 1npm install hexo-deployer-git --save 执行这个命令进行部署: 1hexo deploy 然后再浏览器中输入 http://luojinghui.github.io 就行了，我的 github 的账户叫 luojinghui ,把这个改成你 github 的账户名就行了 备注 每次部署的步骤，可按以下三步来进行: 123hexo cleanhexo generatehexo deploy 简写: 12hexo cleanhexo g -d 一些常用命令： 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 主题 这里面有很多主题,可以参考: 入口 图片路径 1.文章在 source/_posts下新建以.md为结尾的文件，编辑器可以用Webstrom、Sublime，支持 markdown 语法 2.修改头像可以直接在主题里的 _config.yml 文件里面修改，友情链接，之类的都在这里 3.创建文章的文件开头格式,可以用我现用的格式去写: 12345678910---title: 填写标题tags: - tag1- tag2date: 2016/6/06 12:20:25reward: 是否支持打赏,填写true或者falsekeywords: 关键词1 关键词2...description: 填写描述--- 4.如果想引用本地图片路径,以根路径作为起始点,就可以了。例如: /img/logo.png 开始打理你的博客吧，有什么问题下面留言,我会回复的。 Q&amp;A 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？ 答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：如何添加多说评论? 答：在主题里的 _config.yml中找到duoshuo:,冒号后面填写你在多说申请用的域名,例如,我申请的是luojinghui.duoshuo.com,那么,在这里就填写luojinghui,就好了 转载请注明原地址，luojh的博客：http://luojh.me 谢谢！ 一生最重 不过饱餐与被爱","tags":[{"name":"Blog","slug":"Blog","permalink":"http://www.luojh.me/tags/Blog/"},{"name":"Personal","slug":"Personal","permalink":"http://www.luojh.me/tags/Personal/"},{"name":"教程","slug":"教程","permalink":"http://www.luojh.me/tags/教程/"}]},{"title":"LDialog-jquery弹窗插件","date":"2016-06-06T04:20:25.000Z","path":"2016/06/06/ldialog/","text":"前一阵子基于jquery开发,项目中遇到了大量的弹窗组件,每个都是重复复制。最近闲下来了,便花费了几天时间,写了此蒙版插件。基于jquery开发，能够适用于所有的弹出对话，弹出，确认，tip，msg提示框等。支持ie9+以及其他新款浏览器。 How to install npm 1npm install --save-dev ldialog bower 1bower install --save-dev ldialog How to use 在头部引入ldialog.css或者压缩过的ldialog.min.css文件,**同时将fonts字体图标文件放置在css同级目录中。 1&lt;link rel=\"stylesheet\" href=\"../css/ldialog.css\"/&gt; 引入jquery以及ldialog.js文件： 12&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"../js/ldialog.js\"&gt;&lt;/script&gt; 当在监听事件中需要弹出对话框或蒙版时，实例化一个蒙版，并初始化,例如：12var dialog = new LDialog(\"test2\");dialog.init(); 就是这么简单,可能有同学想说,为什么创建一个蒙版还是有些麻烦,其实后面还有通过方法创建蒙版,请接着看完文档哦。 LDialog参数说明 new LDialog（arg1, arg2, arg3）可以传入（选填）三个参数： arg1 (字符串) 参数名 数据类型 默认值 描述 备注 arg1 String null 重写蒙版显示内容 可以是纯文本，也可以是html代码 arg2 (对象) 参数名 数据类型 默认值 描述 备注 bg String “” 定义蒙版背景颜色，默认为白色背景 btn Obj { } 定义按钮组 可定义两个按钮，对应的参数是：sure和cancel sure 定义确定按钮样式，值既可以引用已写好的class，也可以为按钮的颜色值；若只需要其中某一个按钮，只定义一个即可 例如：sure: “l-btn-default” 或者 sure: “red” cancel 定义取消按钮样式，用法和sure相同 例如：cancel: “l-btn-default” 或者 cancel: “#eeeeee” cancelTitle String “取消” 重写蒙版底部取消按钮显示文字 sureTitle String “确定” 重写蒙版底部确定按钮显示文字 enterAni String “fadeIn” 定义蒙版进入动画 可自定义引入animate.css动画库的动画class，插件预加载了常用的几种动画 fontColor String “” 定义蒙版字体颜色 footer boolean true 定义蒙版底部按钮组框架是否显示 globalClose boolean false 定义蒙版是否全局关闭 点击蒙版以外区域关闭蒙版 header boolean true 定义蒙版标题模块是否显示 icon boolean true 定义蒙版内容块图标是否显示 iconColor String null 定义内容块左边图标大小 iconData String null 定义图标源 若arg3参数也定义此参数，以arg2参数定义为准 iconSize String null 定义内容块左边图标大小 minHeight String “50px” 定义蒙版最低高度 move boolean true 定义蒙版是否支持拖拽 moveType Number 1 定义蒙版拖拽方式，可选1或者2 1代表经典方式，2代表黑框方式 moveOut boolean false 定义蒙版是否可以拖拽出显示区域 默认不可以 onCancel function null 点击取消按钮的回调函数 onClose function null 点击关闭按钮的回调函数 onGClose function null 点击全局关闭回调函数 onIsNull(posi,i) function true input输入框回调函数,参数posi为当前input的选择器，i代表此input的序号，函数默认返回true onSure(data) function null 点击确定按钮的回调函数,可选data参数，获得所有蒙版input输入框的中的值，以数组形式展现 onSureBefore function null 点击确定按钮前执行的回调函数 和onSure相比，此函数执行时动画效果还未执行 onTimeOut function null 倒计时完毕后的回调函数 opacity Number 0.5 定义蒙版透明度 outline boolean false 定义是否显示outline效果 类似facebook蒙版效果,常用于操作成功的提示信息 radius Strig “2px” 定义蒙版的圆角 shadow String “” 定义蒙版阴影 subtitle String null 定义副标题内容 timeOut Number -1 定义蒙版显示多长时间后消失 默认使用-1代表不消失 title String “初始化标题” 定义蒙版标题 若arg3参数也定义此参数，以arg2参数定义为准 verCenter boolean true 定义蒙版是否居中显示 默认居中，当不居中时，默认距顶部40px width String “450px” 定义蒙版宽度 input Array [ ] 定义输入框组 可配置多个输入框组，参数如下： verCenter 默认：false 输入框组居中显示，设置为真时，leftInfo参数不可用 value 默认：”” 输入框组设定value值 placeH 默认：”” 默认input显示内容 maxlength 默认：”” 输入最多长度字符数 type 默认：”text” 设置输入类型，例如：text，textarea，date， email… notNull 默认：false 设置是否为空 leftInfo 默认：”” 设置input左边文字 说明： 内容左边引用的是字体图标，属性是iconData，插件默认引用了52个常用的字体图标，下面有预览入口，用法如图： 进入查看图片：传送门 arg3(对象、字符串)已经预定义了几组类型的蒙版显示效果，分别是： info、 success 、error 、 confirm 、 input 、 bim、 custom 当使用时，直接赋值给arg3参数相应的字符串即可。 具体形式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var popType = &#123; info: &#123; title: \"信息\", btn: &#123; sure: \"l-btn-info\", cancel: \"l-btn-default\" &#125;, iconData: \"\" &#125;, success: &#123; title: \"成功\", btn: &#123; sure: \"l-btn-success\", cancel: \"l-btn-default\" &#125;, iconData: \"\", iconColor: \"#56BD9D\" &#125;, error: &#123; title: \"错误\", btn: &#123; sure: \"l-btn-error\", cancel: \"l-btn-default\" &#125;, iconData: \"\", iconColor: \"#c9302c\" &#125;, confirm: &#123; title: \"提示\", btn: &#123; sure: \"l-btn-warning\", cancel: \"l-btn-default\" &#125;, iconData: \"\", iconColor: \"#F0AD4E\" &#125;, input: &#123; title: \"输入\", btn: &#123; sure: \"l-btn-primary\", cancel: \"l-btn-default\" &#125; &#125;, bim: &#123; title: \"提示\", btn: &#123; sure: \"l-btn-bim\", cancel: \"l-btn-default\" &#125; &#125;, custom: &#123; title: \"初始化标题\", btn: &#123; sure: \"l-btn-primary\", cancel: \"l-btn-default\" &#125; &#125;&#125;; 按钮组预定了6组： l-btn-default 、 l-btn-primary 、 l-btn-error 、 l-btn-success 、 l-btn-info、 l-btn-warning 样式可在底部demo页面中查看 方法 LDialog.prompt(value, con, fun) 弹出类似系统的prompt对话框，默认含有一个input输入框。 value：必填，显示的文字，可以为空。con： 选填，配置样式，可使用插件arg2的参数fun： 选填，确认按钮的回调函数，用来获得数据，处理数据 example： 1234567891011121314151617181920var con = &#123; input: [&#123; type: \"textarea\" &#125;], width: \"400px\", onIsNull: function(position, i) &#123; if(position.val() === \"\") &#123; position.focus(); LDialog.tips(\"请输入正确的值,\",position, &#123;posi: 2&#125;); return false; &#125; return true; &#125;&#125;;LDialog.prompt(\"\", con, function(v) &#123; if(v[0] !== \"\") &#123; LDialog.closeAllTips(); console.log(v); &#125;&#125;); LDialog.alert(value, con, fun) example: 12345LDialog.alert(\"123123123123123\");LDialog.alert(\"123123123123123\", function() &#123; console.log(\"点击确定按钮了！\");&#125;); 和prompt方法使用相同，但是alert只有确定按钮，没有input输入框。 LDialog.confirm(value, con, fun) example: 123LDialog.confirm(value, &#123;iconData: \"\"&#125;, function() &#123; LDialog.msg(\"删除成功！\", &#123;iconData: \"\", iconColor: \"green\", iconSize: \"30px\"&#125;);&#125;); 和prompt方法使用相同，但是confirm没有input输入框。 LDialog.msg(value, con, fun) value：必填，显示的文字，可以为空。con： 选填，配置样式，可使用插件arg2的参数fun： 选填，倒计时过后的回调函数，用来阻断函数执行。 example: 123LDialog.msg(\"删除成功！\", &#123;iconData: \"\"&#125;, function() &#123; console.log(123);&#125;); LDialog.tip(value, con, fun) 和msg方法使用相同，但样式不同。 LDialog.tips(value, selector, con) value：必填，显示的文字，可以为空。selector： 必填，显示tips出现的位置，可以为任意jquery的选择器。con： 选填，用来配置tips显示效果，具体参数如下： posi: 2, //默认显示在选择器的右边位置，可定义分别对应的位置： 1：上， 2： 右， 3： 下， 4： 左 bg: \"#000\", //定义tips背景色，默认为黑色 color: \"#fff\", //定义tips文字颜色，默认为白色 maxWidth: \"150\", //定义tips最大宽度，默认为150px timeOut: 2000, //定义tips多少秒后消失。 tipsClose: $.noop //定义tips倒计时回调函数 Live Demo插件demo：传送门 字体图标： 传送门 git地址： 传送门 版本 Version 1.0.0 ：完成蒙版基础功能。 Version 1.0.1 ：增加蒙版居中、全局关闭、自定义进入动画、outline功能。 Version 1.0.2 ：增加对sea.js的支持。 Version 1.0.3 ：增加蒙版实时居中，增加蒙版多种拖拽方式的功能。 Version 1.0.4 ：增加了tip，confirm，msg，prompt，的插件方法，能够快速创建蒙版，并执行回调。 Version 1.0.5 ：修改了一些bug，增加tips指示框方法，能够快速定位到想要出现的位置。 一生最重 不过饱餐与被爱","tags":[{"name":"jquery","slug":"jquery","permalink":"http://www.luojh.me/tags/jquery/"},{"name":"ldialog","slug":"ldialog","permalink":"http://www.luojh.me/tags/ldialog/"},{"name":"model","slug":"model","permalink":"http://www.luojh.me/tags/model/"}]},{"title":"利用Css3画各种几何图形(-)","date":"2016-03-10T08:20:25.000Z","path":"2016/03/10/css/index/","text":".main { margin: 20px; } .inline { display: inline-block; margin-left: 20px; vertical-align: middle; } .rectangle { width: 100px; height: 80px; background-color: #669; } .trapezoid { border-bottom: 50px solid #669; border-left: 25px solid transparent; border-right: 25px solid transparent; width: 80px; } .parallelogram { width: 80px; height: 50px; -webkit-transform: skew(-20deg); -moz-transform: skew(-20deg); -o-transform: skew(-20deg); background: #669; } .triangle-up { display: inline-block; border-width: 0px 30px 50px 30px; border-color: transparent transparent #669 transparent; border-style: solid; } .triangle-bottom { display: inline-block; border-width: 50px 30px 0px 30px; border-color: #669 transparent transparent transparent; border-style: solid; } .triangle-left { display: inline-block; border-width: 30px 50px 30px 0px; border-color: transparent #669 transparent transparent; border-style: solid; } .triangle-right { display: inline-block; border-width: 30px 0px 30px 50px; border-color: transparent transparent transparent #669; border-style: solid; } .triangle-updown { width: 0; height: 0; border-left: 46px solid transparent; border-right: 46px solid transparent; border-bottom: 60px solid #669; position: relative; } .triangle-updown:after { content: \" \"; width: 0; height: 0; border-left: 46px solid transparent; border-right: 46px solid transparent; border-top: 60px solid #669; position: absolute; top: 20px; left: -45px; } .triangle-topleft { width: 0; height: 0; border-top: 50px solid #669; border-right: 50px solid transparent; } .triangle-topright { width: 0; height: 0; border-top: 50px solid #669; border-left: 50px solid transparent; } .triangle-bottomleft { width: 0; height: 0; border-left: 50px solid #669; border-top: 50px solid transparent; } .triangle-bottomright { width: 0; height: 0; border-right: 50px solid #669; border-top: 50px solid transparent; } .one { width: 0; height: 0; border-top: 25px solid #669; border-right: 25px solid transparent; border-bottom: 25px solid #669; border-left: 25px solid #669; } .two { width: 0; height: 0; border-top: 25px solid #669; border-right: 25px solid transparent; border-bottom: 25px solid #669; } .three { width: 0; height: 0; border-top: 50px solid #669; border-right: 50px solid transparent; border-left: 50px solid #669; } .four { display: inline-block; border-width: 25px; border-style: solid; border-color: antiquewhite burlywood lightblue lightsalmon; } .solid-ring { width: 50px; height: 50px; border-radius: 999px; background-color: #669; } .circle-circle { width: 50px; height: 50px; border-radius: 999px; background-color: #fff; border: 10px solid #669; } .circle-top { border-radius: 999px 999px 0 0; border-top: 25px solid #669; width: 50px; } .circle-bottom { border-radius: 0 0 999px 999px; border-bottom: 25px solid #669; width: 50px; } .circle-left { width: 25px; border-bottom: 25px solid #669; border-top: 25px solid #669; border-radius: 999px 0 0 999px; } .circle-right { width: 25px; border-bottom: 25px solid #669; border-top: 25px solid #669; border-radius: 0 999px 999px 0; } .circle-top-left { display: inline-block; border: 25px solid #669; border-top-left-radius: 999px; } .circle-top-right { display: inline-block; border: 25px solid #669; border-top-right-radius: 999px; } .circle-bottom-left { display: inline-block; border: 25px solid #669; border-bottom-left-radius: 999px; } .circle-bottom-right { display: inline-block; border: 25px solid #669; border-bottom-right-radius: 999px; } .u { width: 50px; border: 1px solid #669; border-radius: 0 0 999px 999px; height: 25px; } #cut-diamond { border-style: solid; border-color: transparent transparent #669 transparent; border-width: 8px 15px 20px 15px; height: 0; width: 50px; position: relative; margin-bottom: 24px; } #cut-diamond:after { content: \"\"; position: absolute; top: 19px; left: -15px; width: 0; height: 0; border-style: solid; border-color: #669 transparent transparent transparent; border-width: 35px 25px 0 25px; } .egg { width: 35px; height: 50px; background-color: #669; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; } #infinity { position: relative; width: 104px; height: 50px; } #infinity:before, #infinity:after { content: \"\"; position: absolute; top: 0; left: 0; width: 50px; height: 50px; border: 11px solid #669; border-radius: 50px 50px 0 50px; transform: rotate(-45deg); } #infinity:after { left: auto; right: 0; border-radius: 50px 50px 50px 0; transform: rotate(45deg); } .heart { position: relative; width: 50px; height: 50px; } .heart:before, .heart:after { position: absolute; content: \"\"; left: 0px; top: 0; width: 30px; height: 50px; background-color: #669; border-radius: 999px 999px 0 0; transform: rotate(-45deg); } .heart:after { transform: rotate(45deg); left: 14px; } .star-five { display: inline-block; position: relative; border-right: 10px solid transparent; border-bottom: 25px solid #669; border-left: 10px solid transparent; margin-bottom: 34px; } .star-five:before, .star-five:after { position: absolute; content: \"\"; border-right: 25px solid #669; border-top: 35px solid transparent; border-bottom: 35px solid transparent; transform: rotate(54deg); left: -15px; top: -2px; } .star-five:after { content: \"\"; transform: rotate(125deg); top: -2px; left: -11px; } .tail-left-top { border: 0 solid transparent; border-top: 25px solid #669; border-radius: 55px 0 0 0; width: 55px; height: 50px; } .tail-right-top { width: 55px; height: 50px; border: 0 solid transparent; border-top: 25px solid #669; border-radius: 0 55px 0 0; } .tail-left-bottom { width: 55px; height: 50px; border: 0 solid transparent; border-bottom: 25px solid #669; border-radius: 0 0 0 55px; } .tail-right-bottom { width: 55px; height: 50px; border: 0 solid transparent; border-bottom: 25px solid #669; border-radius: 0 0 55px 0; } .talk-box { width: 100px; height: 50px; border-radius: 6px; background-color: #669; position: relative; margin-left: 49px; } .talk-box:after { content: \"\"; position: absolute; border: 0 solid transparent; width: 27px; height: 40px; bottom: -21px; left: -26px; border-top: 15px solid #669; border-radius: 55px 0 0 0; } .tips { position: relative; width: 120px; height: 46px; background-color: #fff; border: 1px solid #669; border-radius: 6px; padding: 2px; text-align: center; } .tips:before { content: \"\"; position: absolute; left: -15px; top: 17px; border-top: 7px solid transparent; border-bottom: 7px solid transparent; border-right: 15px solid #669; } .tips:after { content: \"\"; position: absolute; left: -13px; top: 18px; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-right: 13px solid #fff; } pre { background-color: #eee!important; border: none!important; text-shadow: none!important; border-radius: 4px!important; padding: 15px!important; } .mt10 { margin-top: 20px; } .mb30 { margin-bottom: 30px; } .mb50 { margin-bottom: 50px; } .ml20 { margin-left: 20px; } 早前学习css3的练习,通过纯css实现基本的图形,熟悉css的属性应用。今天抽空整理出来,分享给想要学习css的同学。 .rectangle { width: 100px; height: 80px; background-color: #669; } .trapezoid { border-bottom: 50px solid #669; border-left: 25px solid transparent; border-right: 25px solid transparent; width: 80px; } .parallelogram { width: 80px; height: 50px; -webkit-transform: skew(-20deg); -moz-transform: skew(-20deg); -o-transform: skew(-20deg); background: #669; } .triangle-up { display: inline-block; border-width: 0px 30px 50px 30px; border-color: transparent transparent #669 transparent; border-style: solid; } .triangle-bottom { border-width: 50px 30px 0px 30px; border-color: #669 transparent transparent transparent; border-style: solid; } .triangle-left { display: inline-block; border-width: 30px 50px 30px 0px; border-color: transparent #669 transparent transparent; border-style: solid; } .triangle-right { display: inline-block; border-width: 30px 0px 30px 50px; border-color: transparent transparent transparent #669; border-style: solid; } .triangle-updown { width: 0; height: 0; border-left: 46px solid transparent; border-right: 46px solid transparent; border-bottom: 60px solid #669; position: relative; } .triangle-updown:after { content: \" \"; width: 0; height: 0; border-left: 46px solid transparent; border-right: 46px solid transparent; border-top: 60px solid #669; position: absolute; top: 20px; left: -45px; } .triangle-topleft { width: 0; height: 0; border-top: 50px solid #669; border-right: 50px solid transparent; } .triangle-topright { width: 0; height: 0; border-top: 50px solid #669; border-left: 50px solid transparent; } .triangle-bottomleft { width: 0; height: 0; border-left: 50px solid #669; border-top: 50px solid transparent; } .triangle-bottomright { width: 0; height: 0; border-right: 50px solid #669; border-top: 50px solid transparent; } .one { width: 0; height: 0; border-top: 25px solid #669; border-right: 25px solid transparent; border-bottom: 25px solid #669; border-left: 25px solid #669; } .two { width: 0; height: 0; border-top: 25px solid #669; border-right: 25px solid transparent; border-bottom: 25px solid #669; } .three { width: 0; height: 0; border-top: 50px solid #669; border-right: 50px solid transparent; border-left: 50px solid #669; } .four { display: inline-block; border-width: 25px; border-style: solid; border-color: antiquewhite burlywood lightblue lightsalmon; } .solid-ring { width: 50px; height: 50px; border-radius: 999px; background-color: #669; } .circle-circle { width: 50px; height: 50px; border-radius: 999px; background-color: #fff; border: 10px solid #669; } .circle-top { border-radius: 999px 999px 0 0; border-top: 25px solid #669; width: 50px; } .circle-bottom { border-radius: 0 0 999px 999px; border-bottom: 25px solid #669; width: 50px; } .circle-left { width: 25px; border-bottom: 25px solid #669; border-top: 25px solid #669; border-radius: 999px 0 0 999px; } .circle-right { width: 25px; border-bottom: 25px solid #669; border-top: 25px solid #669; border-radius: 0 999px 999px 0; } .circle-top-left { display: inline-block; border: 25px solid #669; border-top-left-radius: 999px; } .circle-top-right { display: inline-block; border: 25px solid #669; border-top-right-radius: 999px; } .circle-bottom-left { display: inline-block; border: 25px solid #669; border-bottom-left-radius: 999px; } .circle-bottom-right { display: inline-block; border: 25px solid #669; border-bottom-right-radius: 999px; } .u { width: 50px; border: 1px solid #669; border-radius: 0 0 999px 999px; height: 25px; } #cut-diamond { border-style: solid; border-color: transparent transparent #669 transparent; border-width: 8px 15px 20px 15px; height: 0; width: 50px; position: relative; margin-bottom: 24px; } #cut-diamond:after { content: \"\"; position: absolute; top: 19px; left: -15px; width: 0; height: 0; border-style: solid; border-color: #669 transparent transparent transparent; border-width: 35px 25px 0 25px; } .egg { width: 35px; height: 50px; background-color: #669; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; } #infinity { position: relative; width: 104px; height: 50px; } #infinity:before, #infinity:after { content: \"\"; position: absolute; top: 0; left: 0; width: 50px; height: 50px; border: 11px solid #669; border-radius: 50px 50px 0 50px; transform: rotate(-45deg); } #infinity:after { left: auto; right: 0; border-radius: 50px 50px 50px 0; transform: rotate(45deg); } .heart { position: relative; width: 50px; height: 50px; } .heart:before, .heart:after { position: absolute; content: \"\"; left: 0px; top: 0; width: 30px; height: 50px; background-color: #669; border-radius: 999px 999px 0 0; transform: rotate(-45deg); } .heart:after { transform: rotate(45deg); left: 14px; } .star-five { display: inline-block; position: relative; border-right: 10px solid transparent; border-bottom: 25px solid #669; border-left: 10px solid transparent; margin-bottom: 34px; } .star-five:before, .star-five:after { position: absolute; content: \"\"; border-right: 25px solid #669; border-top: 35px solid transparent; border-bottom: 35px solid transparent; transform: rotate(54deg); left: -15px; top: -2px; } .star-five:after { content: \"\"; transform: rotate(125deg); top: -2px; left: -11px; } .tail-left-top { border: 0 solid transparent; border-top: 25px solid #669; border-radius: 55px 0 0 0; width: 55px; height: 50px; } .tail-right-top { width: 55px; height: 50px; border: 0 solid transparent; border-top: 25px solid #669; border-radius: 0 55px 0 0; } .tail-left-bottom { width: 55px; height: 50px; border: 0 solid transparent; border-bottom: 25px solid #669; border-radius: 0 0 0 55px; } .tail-right-bottom { width: 55px; height: 50px; border: 0 solid transparent; border-bottom: 25px solid #669; border-radius: 0 0 55px 0; } .talk-box { width: 100px; height: 50px; border-radius: 6px; background-color: #669; position: relative; margin-left: 49px; } .talk-box:after { content: \"\"; position: absolute; border: 0 solid transparent; width: 27px; height: 40px; bottom: -21px; left: -26px; border-top: 15px solid #669; border-radius: 55px 0 0 0; } luojh.me .tips { position: relative; width: 120px; height: 46px; background-color: #fff; border: 1px solid #669; border-radius: 6px; padding: 2px; text-align: center; } .tips:before { content: \"\"; position: absolute; left: -15px; top: 17px; border-top: 7px solid transparent; border-bottom: 7px solid transparent; border-right: 15px solid #669; } .tips:after { content: \"\"; position: absolute; left: -13px; top: 18px; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-right: 13px solid #fff; } 一生最重 不过饱餐与被爱","tags":[{"name":"css3","slug":"css3","permalink":"http://www.luojh.me/tags/css3/"}]},{"title":"Scss学习笔记","date":"2016-01-12T04:20:25.000Z","path":"2016/01/12/css/scss-demo/","text":"Scss的学习笔记,记录下来,以此纪念。 语法 sass 有两种语法。 第一种被称为 SCSS (sassy CSS)，是一个 CSS3 语法的扩充版本，本片教程就是基于此语法。 第二种比较老的语法成为缩排语法（或者就称为 “sass”）， 提供了一种更简洁的 CSS 书写方式。 它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，I 而且也不使用分号，而是用换行符来分隔属性。 任一语法都可以导入另一种语法撰写的文件中。 只要使用 sass-convert 命令行工具，就可以将一种语法转换为另一种语法：12345# 将 sass 转换为 SCSS$ sass-convert style.sass style.scss# 将 SCSS 转换为 sass$ sass-convert style.scss style.sass 使用 sass第一步需要安装sass(mac命令):1gem install sass sass提供四个编译风格的选项：1234567nested：嵌套缩进的css代码，它是默认值。expanded：没有缩进的、扩展的css代码。compact：简洁格式的css代码。compressed：压缩后的css代码。 如果要在命令行中运行 sass ,只要输入:1sass input.scss output.css 生产环境当中，一般使用最后一个选项:1sass --style compressed test.sass test.css 你也可以让sass监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本:12345// watch a filesass --watch ./public/scss/demo1.scss:./public/css/demo1.css// watch a directorysass --style expanded --watch ./public/scss:./public/css 变量,计算sass允许使用变量，所有变量以$开头:123456789101112131415161718$side : left;$fontSize : 18px*2;$var : 2;body &#123; margin: (14px/2); //output: 7px top: 50px + 100px; //output: 150px right: $var * 10%; //output: 20%&#125;.rounded &#123; border-#&#123;$side&#125;-radius: 5px; //output: border-left-radius: 5px&#125;.box &#123; color: #333; font-size: $fontSize; //output: 36px&#125; 嵌套sass允许选择器嵌套:123456789div &#123; h1 &#123; color: red; &#125;&#125;//output: div h1 &#123; color: red;&#125; 属性也可以嵌套，比如border-color属性，可以写成：1234567891011121314p &#123; border: &#123; color: #ddd; width: 1px; style: solid; &#125;&#125;//output: p &#123; border-color: #ddd; border-width: 1px; border-style: solid;&#125; 1234567891011121314.funky &#123; font: 2px/3px &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125;//output:.funky &#123; font: 2px/3px; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 引用父选择符1234567891011121314a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125;//output:a &#123; font-weight: bold; text-decoration: none; &#125; a:hover &#123; text-decoration: underline; &#125; body.firefox a &#123; //a标签被移到body属性之后 font-weight: normal; &#125; 注释: /* */ and //sass共有两种注释风格: 标准的CSS注释 /* comment */ ，会保留到编译后的文件。(在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。) 单行注释 // comment，只保留在sass源文件中，编译后被省略。 数据类型sassScript 支持六种主要的数据类型： 数字（例如 1.2、13、10px） 文本字符串，无论是否有引号（例如 “foo”、’bar’、baz） 颜色（例如 blue、#04a3f9、rgba(255, 0, 0, 0.5)） 布尔值（例如 true、false） 空值（例如 null） 值列表，用空格或逗号分隔（例如 1.5em 1em 0 2em、Helvetica, Arial, sans-serif） sassScript 还支持所有其他 CSS 属性值类型， 例如 Unicode 范围和 !important 声明。 然而，它不会对这些类型做特殊处理。 它们只会被当做不带引号的字符串看待。 插入文件sass 扩展了 CSS 的 @import 规则，让它能够引入 SCSS 和 sass 文件。 所有引入的 SCSS 和 sass 文件都会被合并并输出一个单一的 CSS 文件。 另外，被导入的文件中所定义的变量或 mixins 都可以在主文件中使用。123@import \"path/filename.scss\";or@import \"path/filename\"; 也可以通过一个 @import 引入多个文件。例如：1@import \"rounded-corners\", \"text-shadow\"; MixinMixin可以重用的代码块,使用@mixin命令，定义一个代码块。1234567891011121314151617181920212223242526272829303132333435@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125;//output:.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; Mixin Arguments1234567891011121314151617181920212223242526272829@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;//Mixins还可以使用正常的变量设置语法为其参数指定默认值。然后当包含mixin时，如果它不传递参数，将使用默认值。例如：p &#123; @include sexy-border(blue, 1in); &#125;//output:p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; @mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;//output:p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; Keyword ArgumentsMixin也可以使用显式关键字参数。例如，我们上面的例子可以写:12p &#123; @include sexy-border($color: blue); &#125;h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125; 使用...获得所有参数:12345678910111213141516@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125;//output:.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 颜色函数sass提供了一些内置的颜色函数，以便生成系列颜色:1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 函数可以在sass中定义自己的函数，并在任何值或脚本上下文中使用它们。例如：123456789101112131415$grid-width: 40px;$gutter-width: 10px;@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;#sidebar &#123; width: grid-width(5); &#125;//output:#sidebar &#123; width: 240px; &#125; //与mixins一样，您可以使用关键字参数调用sass定义的函数。在上面的例子中，我们可以像这样调用函数： #sidebar &#123; width: grid-width($n: 5); &#125; @each123456789101112131415@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125;//output:.puma-icon &#123; background-image: url('/images/puma.png'); &#125;.sea-slug-icon &#123; background-image: url('/images/sea-slug.png'); &#125;.egret-icon &#123; background-image: url('/images/egret.png'); &#125;.salamander-icon &#123; background-image: url('/images/salamander.png'); &#125; 看我上面的文章，大家有什么感受呢？你可以按照描述，安装好sass,然后边看边自己用记事本把上面的案例敲一遍，运行一遍，经过这一遍学习之后，相信您已经sass入门了，将来的sass进阶，请看后面的文章了！ 要是您有什么问题，可以留言交流！ 一生最重 不过饱餐与被爱","tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.luojh.me/tags/笔记/"},{"name":"Css3","slug":"Css3","permalink":"http://www.luojh.me/tags/Css3/"},{"name":"Scss","slug":"Scss","permalink":"http://www.luojh.me/tags/Scss/"},{"name":"sass","slug":"sass","permalink":"http://www.luojh.me/tags/sass/"}]}]